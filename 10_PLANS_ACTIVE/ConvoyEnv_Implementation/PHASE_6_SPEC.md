# Phase 6 Specification: Episode Management

**Generated by:** PLANNER Agent
**Date:** January 10, 2026
**For:** BUILDER Agent
**Status:** Ready for Implementation

---

## Status Update

| Phase | Tests | Status |
|-------|-------|--------|
| Phase 0-5 | 58/58 | COMPLETE |
| **Phase 6** | 0/15 | **NOW** |
| Total | 58/80 | 72.5% |

---

## Phase 6 Objective

Implement episode lifecycle management for `ConvoyEnv`:

1. **`reset()`** - Initialize new episode with clean state
2. **Collision detection** - Terminate episode on collision (d < 5m)
3. **Truncation conditions** - End episode on max_steps or vehicle exit
4. **`HazardInjector`** - Probabilistically inject emergency braking events

---

## Prerequisites Verified

| Dependency | Status | Location |
|------------|--------|----------|
| SUMOConnection (start/stop/step) | DONE | `sumo_connection.py` |
| ObservationBuilder (build) | DONE | `observation_builder.py` |
| ActionApplicator (apply) | DONE | `action_applicator.py` |
| RewardCalculator (calculate) | DONE | `reward_calculator.py` |
| ESP-NOW Emulator | DONE | `espnow_emulator.py` |

---

## Architecture: ConvoyEnv Flow

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                         EPISODE LIFECYCLE                                    │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                              │
│  reset(seed=None)                                                           │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │ 1. Clear emulator message queue                                       │   │
│  │ 2. Restart SUMO simulation (traci.load() or stop+start)             │   │
│  │ 3. Initialize step counter to 0                                      │   │
│  │ 4. Set RNG seed if provided                                          │   │
│  │ 5. Get initial vehicle states                                        │   │
│  │ 6. Build initial observation                                         │   │
│  │ 7. Return (observation, info)                                        │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                                │                                             │
│                                ▼                                             │
│  step(action) ─── Episode Loop ──────────────────────────────────────────   │
│  ┌──────────────────────────────────────────────────────────────────────┐   │
│  │ 1. Apply action via ActionApplicator                                 │   │
│  │ 2. Advance SUMO simulation                                           │   │
│  │ 3. Get vehicle states                                                │   │
│  │ 4. Calculate distance to nearest lead vehicle                        │   │
│  │ 5. Check collision (d < 5m) → terminated=True                       │   │
│  │ 6. Check truncation (max_steps OR vehicle_exited)                   │   │
│  │ 7. Maybe inject hazard (HazardInjector)                             │   │
│  │ 8. Transmit peer states to emulator                                 │   │
│  │ 9. Build observation                                                 │   │
│  │ 10. Calculate reward                                                 │   │
│  │ 11. Return (obs, reward, terminated, truncated, info)               │   │
│  └──────────────────────────────────────────────────────────────────────┘   │
│                                                                              │
└─────────────────────────────────────────────────────────────────────────────┘
```

---

## Implementation Specifications

### 6.1 ConvoyEnv Extension

```python
# ml/envs/convoy_env.py

import gymnasium as gym
from gymnasium import spaces
import numpy as np
from typing import Optional, Dict, Any, Tuple

from envs.sumo_connection import SUMOConnection, VehicleState
from envs.observation_builder import ObservationBuilder
from envs.action_applicator import ActionApplicator
from envs.reward_calculator import RewardCalculator
from envs.hazard_injector import HazardInjector
from espnow_emulator.espnow_emulator import ESPNOWEmulator


class ConvoyEnv(gym.Env):
    """
    RoadSense V2V Convoy Environment.

    A 3-vehicle convoy following scenario with ESP-NOW communication effects.
    The ego vehicle (V001) follows V002 and V003, receiving V2V messages
    with realistic latency, packet loss, and staleness.

    Observation Space:
        Box(11,) - [ego_speed, v002_*, v003_*]

    Action Space:
        Discrete(4) - [Maintain, Caution, Brake, Emergency]

    Reward:
        Distance-based safety rewards with comfort and appropriateness penalties.
    """

    metadata = {"render_modes": ["human"], "render_fps": 10}

    # Vehicle IDs
    EGO_VEHICLE_ID = "V001"
    LEAD_VEHICLE_IDS = ["V002", "V003"]

    # Episode configuration
    DEFAULT_MAX_STEPS = 1000  # 100 seconds at 10 Hz

    # Distance thresholds (must match RewardCalculator)
    COLLISION_DIST = 5.0  # meters

    def __init__(
        self,
        sumo_cfg: str,
        emulator: Optional[ESPNOWEmulator] = None,
        emulator_params_path: Optional[str] = None,
        max_steps: int = DEFAULT_MAX_STEPS,
        hazard_injection: bool = True,
        render_mode: Optional[str] = None,
        gui: bool = False,
    ):
        """
        Initialize ConvoyEnv.

        Args:
            sumo_cfg: Path to SUMO .sumocfg file
            emulator: Pre-configured ESPNOWEmulator (optional)
            emulator_params_path: Path to emulator_params.json (if emulator not provided)
            max_steps: Maximum steps per episode (default 1000)
            hazard_injection: Enable random hazard injection (default True)
            render_mode: Gymnasium render mode ("human" for GUI)
            gui: Launch SUMO with GUI (alternative to render_mode)
        """
        super().__init__()

        self.sumo_cfg = sumo_cfg
        self.max_steps = max_steps
        self.hazard_injection_enabled = hazard_injection
        self.render_mode = render_mode
        self.gui = gui or (render_mode == "human")

        # Initialize components
        self.sumo = SUMOConnection(sumo_cfg, gui=self.gui)

        if emulator is not None:
            self.emulator = emulator
        elif emulator_params_path is not None:
            self.emulator = ESPNOWEmulator.from_json(emulator_params_path)
        else:
            self.emulator = ESPNOWEmulator()  # Default parameters

        self.obs_builder = ObservationBuilder()
        self.action_applicator = ActionApplicator()
        self.reward_calculator = RewardCalculator()
        self.hazard_injector = HazardInjector() if hazard_injection else None

        # State variables
        self._step_count = 0
        self._sumo_started = False
        self._np_random = None

        # Define spaces (MUST match ObservationBuilder output)
        self.observation_space = spaces.Box(
            low=-np.inf,
            high=np.inf,
            shape=(11,),
            dtype=np.float32
        )
        self.action_space = spaces.Discrete(4)

    def reset(
        self,
        seed: Optional[int] = None,
        options: Optional[Dict[str, Any]] = None
    ) -> Tuple[np.ndarray, Dict[str, Any]]:
        """
        Reset environment to initial state.

        Args:
            seed: Random seed for reproducibility
            options: Additional reset options (unused)

        Returns:
            Tuple of (observation, info)
        """
        # Handle seeding (Gymnasium pattern)
        super().reset(seed=seed)

        # Clear emulator message queue (CRITICAL for no state leak)
        self.emulator.clear()

        # Reset step counter
        self._step_count = 0

        # Restart SUMO simulation
        if self._sumo_started:
            self.sumo.stop()
        self.sumo.start()
        self._sumo_started = True

        # Seed hazard injector if present
        if self.hazard_injector is not None and seed is not None:
            self.hazard_injector.seed(seed)

        # Get initial vehicle states
        ego_state = self.sumo.get_vehicle_state(self.EGO_VEHICLE_ID)

        # Build initial observation (no messages received yet)
        current_time_ms = int(self.sumo.get_simulation_time() * 1000)
        observation = self.obs_builder.build(
            ego_state=ego_state,
            emulator_obs=self.emulator.get_observation(
                ego_speed=ego_state.speed,
                current_time_ms=current_time_ms
            )
        )

        info = {
            "step": 0,
            "simulation_time": self.sumo.get_simulation_time(),
        }

        return observation, info

    def step(self, action: int) -> Tuple[np.ndarray, float, bool, bool, Dict[str, Any]]:
        """
        Execute one timestep.

        Args:
            action: Integer action [0, 3]

        Returns:
            Tuple of (observation, reward, terminated, truncated, info)
        """
        # 1. Apply action to ego vehicle
        actual_decel = self.action_applicator.apply(self.sumo, action)

        # 2. Maybe inject hazard
        hazard_injected = False
        if self.hazard_injector is not None:
            hazard_injected = self.hazard_injector.maybe_inject(
                step=self._step_count,
                sumo=self.sumo
            )

        # 3. Advance simulation
        self.sumo.step()
        self._step_count += 1

        # 4. Get vehicle states
        ego_state = self.sumo.get_vehicle_state(self.EGO_VEHICLE_ID)
        current_time_ms = int(self.sumo.get_simulation_time() * 1000)

        # 5. Get peer states and transmit to emulator
        peer_states = []
        for vid in self.LEAD_VEHICLE_IDS:
            if self.sumo.is_vehicle_active(vid):
                peer_states.append(self.sumo.get_vehicle_state(vid))

        self._transmit_vehicle_states(ego_state, peer_states, current_time_ms)

        # 6. Calculate distance to nearest lead vehicle
        distance = self._calculate_min_distance(ego_state, peer_states)

        # 7. Check termination conditions
        terminated = False
        truncated = False

        # Collision check
        if distance < self.COLLISION_DIST:
            terminated = True

        # Truncation checks
        if self._step_count >= self.max_steps:
            truncated = True

        # Vehicle exit check (any lead vehicle left the simulation)
        if not self._all_vehicles_active():
            truncated = True

        # 8. Build observation
        observation = self.obs_builder.build(
            ego_state=ego_state,
            emulator_obs=self.emulator.get_observation(
                ego_speed=ego_state.speed,
                current_time_ms=current_time_ms
            )
        )

        # 9. Calculate reward
        reward, reward_info = self.reward_calculator.calculate(
            distance=distance,
            action=action,
            deceleration=actual_decel
        )

        # 10. Build info dict
        info = {
            "step": self._step_count,
            "simulation_time": self.sumo.get_simulation_time(),
            "distance": distance,
            "hazard_injected": hazard_injected,
            **reward_info
        }

        return observation, reward, terminated, truncated, info

    def _calculate_min_distance(
        self,
        ego_state: VehicleState,
        peer_states: list
    ) -> float:
        """
        Calculate minimum distance from ego to any peer vehicle.

        Uses Euclidean distance in SUMO coordinate space.
        Returns large value (1000.0) if no peers exist.
        """
        if not peer_states:
            return 1000.0  # No peers, return safe distance

        min_dist = float('inf')
        for peer in peer_states:
            dx = peer.x - ego_state.x
            dy = peer.y - ego_state.y
            dist = (dx**2 + dy**2)**0.5
            min_dist = min(min_dist, dist)

        return min_dist

    def _all_vehicles_active(self) -> bool:
        """Check if ego and at least one lead vehicle are active."""
        if not self.sumo.is_vehicle_active(self.EGO_VEHICLE_ID):
            return False
        # Need at least one lead vehicle active
        for vid in self.LEAD_VEHICLE_IDS:
            if self.sumo.is_vehicle_active(vid):
                return True
        return False

    def render(self) -> None:
        """Render current state (SUMO GUI handles this)."""
        pass  # SUMO GUI auto-renders when gui=True

    def close(self) -> None:
        """Clean up resources."""
        if self._sumo_started:
            self.sumo.stop()
            self._sumo_started = False
```

---

### 6.2 HazardInjector Class

```python
# ml/envs/hazard_injector.py

from typing import Optional
import random


class HazardInjector:
    """
    Injects hazard events mid-episode using TraCI.

    SUMO's car-following model is too safe by default - it won't naturally
    create collision scenarios. This class injects emergency brake events
    to create training data for the CRITICAL class.

    Hazard Types:
    - EMERGENCY_BRAKE: Lead vehicle (V002) stops suddenly

    Injection Rules:
    - Probability: ~30% of episodes get a hazard
    - Timing: Only between steps 30-80 (avoid early/late injection)
    - Once per episode: Only one hazard event allowed
    """

    # Configuration constants
    HAZARD_PROBABILITY = 0.3  # 30% chance per episode
    HAZARD_WINDOW_START = 30  # Earliest step for hazard
    HAZARD_WINDOW_END = 80    # Latest step for hazard

    # Hazard type constants
    EMERGENCY_BRAKE = "emergency_brake"

    # Target vehicle for hazard
    HAZARD_TARGET_VEHICLE = "V002"  # Middle vehicle in convoy

    def __init__(self, seed: Optional[int] = None):
        """
        Initialize HazardInjector.

        Args:
            seed: Random seed for reproducibility
        """
        self._rng = random.Random(seed)
        self._hazard_step: Optional[int] = None  # Step when hazard will trigger
        self._hazard_injected = False  # Has hazard been injected this episode
        self._episode_will_have_hazard = False  # Decided at episode start

    def seed(self, seed: int) -> None:
        """
        Set random seed.

        Args:
            seed: Random seed
        """
        self._rng = random.Random(seed)
        self._reset_state()

    def _reset_state(self) -> None:
        """Reset per-episode state. Called at start of each episode."""
        # Decide if this episode will have a hazard
        self._episode_will_have_hazard = self._rng.random() < self.HAZARD_PROBABILITY

        if self._episode_will_have_hazard:
            # Pre-determine when hazard will occur
            self._hazard_step = self._rng.randint(
                self.HAZARD_WINDOW_START,
                self.HAZARD_WINDOW_END
            )
        else:
            self._hazard_step = None

        self._hazard_injected = False

    def reset(self) -> None:
        """Reset for new episode."""
        self._reset_state()

    def maybe_inject(self, step: int, sumo: "SUMOConnection") -> bool:
        """
        Possibly inject a hazard event at this step.

        Args:
            step: Current step number (0-indexed)
            sumo: SUMOConnection instance for TraCI calls

        Returns:
            True if hazard was injected, False otherwise
        """
        # Already injected this episode
        if self._hazard_injected:
            return False

        # Episode doesn't have hazard
        if not self._episode_will_have_hazard:
            return False

        # Not the right step
        if self._hazard_step is None or step != self._hazard_step:
            return False

        # Check if target vehicle is active
        if not sumo.is_vehicle_active(self.HAZARD_TARGET_VEHICLE):
            return False

        # INJECT EMERGENCY BRAKE
        sumo.set_vehicle_speed(self.HAZARD_TARGET_VEHICLE, 0.0)
        self._hazard_injected = True

        return True

    def is_in_hazard_window(self, step: int) -> bool:
        """
        Check if current step is within hazard injection window.

        Args:
            step: Current step number

        Returns:
            True if step is in [HAZARD_WINDOW_START, HAZARD_WINDOW_END]
        """
        return self.HAZARD_WINDOW_START <= step <= self.HAZARD_WINDOW_END

    @property
    def hazard_injected(self) -> bool:
        """Whether a hazard was injected this episode."""
        return self._hazard_injected
```

---

## Test Specifications

### Test File: `ml/tests/unit/test_convoy_env.py`

```python
import pytest
import numpy as np
from unittest.mock import Mock, MagicMock, patch

from envs.convoy_env import ConvoyEnv
from envs.sumo_connection import VehicleState


# === Fixtures ===

@pytest.fixture
def mock_sumo():
    """Mock SUMOConnection for unit tests."""
    mock = Mock()
    mock.start = Mock()
    mock.stop = Mock()
    mock.step = Mock()
    mock.get_simulation_time = Mock(return_value=0.0)
    mock.is_vehicle_active = Mock(return_value=True)

    # Default vehicle state (safe following)
    mock.get_vehicle_state = Mock(return_value=VehicleState(
        vehicle_id="V001",
        x=0.0, y=0.0,
        speed=20.0,
        acceleration=0.0,
        heading=0.0,
        lane_position=0.0
    ))
    return mock


@pytest.fixture
def mock_emulator():
    """Mock ESPNOWEmulator for unit tests."""
    mock = Mock()
    mock.clear = Mock()
    mock.transmit = Mock()
    mock.get_observation = Mock(return_value={
        'V002': {'rel_dist': 30.0, 'rel_speed': 0.0, 'accel': 0.0, 'age_ms': 10, 'valid': True},
        'V003': {'rel_dist': 60.0, 'rel_speed': 0.0, 'accel': 0.0, 'age_ms': 15, 'valid': True},
    })
    return mock


@pytest.fixture
def env_with_mocks(mock_sumo, mock_emulator, tmp_path):
    """ConvoyEnv with mocked dependencies."""
    # Create minimal sumocfg
    cfg = tmp_path / "test.sumocfg"
    cfg.write_text("<configuration></configuration>")

    with patch('envs.convoy_env.SUMOConnection', return_value=mock_sumo):
        env = ConvoyEnv(
            sumo_cfg=str(cfg),
            emulator=mock_emulator,
            hazard_injection=False
        )
        yield env
        env.close()


# === Reset Tests (5 tests) ===

def test_reset_returns_observation_and_info(env_with_mocks):
    """reset() returns (obs, info) tuple."""
    result = env_with_mocks.reset()

    assert isinstance(result, tuple)
    assert len(result) == 2
    obs, info = result
    assert isinstance(obs, np.ndarray)
    assert isinstance(info, dict)


def test_reset_observation_shape_is_11(env_with_mocks):
    """Initial observation has shape (11,)."""
    obs, _ = env_with_mocks.reset()

    assert obs.shape == (11,)
    assert obs.dtype == np.float32


def test_reset_clears_emulator_message_queue(env_with_mocks, mock_emulator):
    """No stale messages from previous episode."""
    env_with_mocks.reset()

    mock_emulator.clear.assert_called_once()


def test_reset_restarts_sumo_simulation(env_with_mocks, mock_sumo):
    """SUMO simulation restarts on reset."""
    # First reset
    env_with_mocks.reset()
    assert mock_sumo.start.call_count == 1

    # Second reset should stop and start again
    env_with_mocks.reset()
    assert mock_sumo.stop.call_count == 1
    assert mock_sumo.start.call_count == 2


def test_reset_with_seed_is_reproducible(tmp_path, mock_emulator):
    """Same seed produces same hazard injection pattern."""
    cfg = tmp_path / "test.sumocfg"
    cfg.write_text("<configuration></configuration>")

    with patch('envs.convoy_env.SUMOConnection') as mock_sumo_class:
        mock_sumo = Mock()
        mock_sumo.start = Mock()
        mock_sumo.stop = Mock()
        mock_sumo.get_simulation_time = Mock(return_value=0.0)
        mock_sumo.is_vehicle_active = Mock(return_value=True)
        mock_sumo.get_vehicle_state = Mock(return_value=VehicleState(
            vehicle_id="V001", x=0.0, y=0.0, speed=20.0,
            acceleration=0.0, heading=0.0, lane_position=0.0
        ))
        mock_sumo_class.return_value = mock_sumo

        env = ConvoyEnv(
            sumo_cfg=str(cfg),
            emulator=mock_emulator,
            hazard_injection=True
        )

        # Reset with same seed twice
        env.reset(seed=42)
        pattern1 = env.hazard_injector._hazard_step

        env.reset(seed=42)
        pattern2 = env.hazard_injector._hazard_step

        assert pattern1 == pattern2

        env.close()


# === Collision Termination Tests (3 tests) ===

def test_collision_sets_terminated_true(env_with_mocks, mock_sumo):
    """Distance < 5m -> terminated=True."""
    env_with_mocks.reset()

    # Set up collision scenario: ego at x=0, peer at x=4 (distance=4m)
    mock_sumo.get_vehicle_state = Mock(side_effect=[
        VehicleState("V001", x=0.0, y=0.0, speed=20.0, acceleration=0.0, heading=0.0, lane_position=0.0),
        VehicleState("V002", x=4.0, y=0.0, speed=0.0, acceleration=0.0, heading=0.0, lane_position=0.0),
        VehicleState("V003", x=100.0, y=0.0, speed=20.0, acceleration=0.0, heading=0.0, lane_position=0.0),
    ])

    _, _, terminated, truncated, _ = env_with_mocks.step(0)

    assert terminated is True
    assert truncated is False


def test_collision_reward_is_negative_100(env_with_mocks, mock_sumo):
    """Collision step reward is -100."""
    env_with_mocks.reset()

    # Set up collision
    mock_sumo.get_vehicle_state = Mock(side_effect=[
        VehicleState("V001", x=0.0, y=0.0, speed=20.0, acceleration=0.0, heading=0.0, lane_position=0.0),
        VehicleState("V002", x=3.0, y=0.0, speed=0.0, acceleration=0.0, heading=0.0, lane_position=0.0),
        VehicleState("V003", x=100.0, y=0.0, speed=20.0, acceleration=0.0, heading=0.0, lane_position=0.0),
    ])

    _, reward, _, _, info = env_with_mocks.step(0)

    assert info['reward_safety'] == -100.0


def test_no_collision_terminated_is_false(env_with_mocks, mock_sumo):
    """Normal step (safe distance) -> terminated=False."""
    env_with_mocks.reset()

    # Safe following: distance = 30m
    mock_sumo.get_vehicle_state = Mock(side_effect=[
        VehicleState("V001", x=0.0, y=0.0, speed=20.0, acceleration=0.0, heading=0.0, lane_position=0.0),
        VehicleState("V002", x=30.0, y=0.0, speed=20.0, acceleration=0.0, heading=0.0, lane_position=0.0),
        VehicleState("V003", x=60.0, y=0.0, speed=20.0, acceleration=0.0, heading=0.0, lane_position=0.0),
    ])

    _, _, terminated, _, _ = env_with_mocks.step(0)

    assert terminated is False


# === Truncation Tests (3 tests) ===

def test_max_steps_sets_truncated_true(env_with_mocks, mock_sumo):
    """After max_steps -> truncated=True."""
    env_with_mocks.max_steps = 5  # Short episode for test
    env_with_mocks.reset()

    # Safe vehicle states
    def make_state(vid):
        x = 0.0 if vid == "V001" else 30.0 if vid == "V002" else 60.0
        return VehicleState(vid, x=x, y=0.0, speed=20.0, acceleration=0.0, heading=0.0, lane_position=0.0)

    mock_sumo.get_vehicle_state = Mock(side_effect=lambda vid: make_state(vid))

    # Run until truncation
    truncated = False
    for i in range(10):
        _, _, terminated, truncated, _ = env_with_mocks.step(0)
        if truncated or terminated:
            break

    assert truncated is True
    assert i == 4  # 5 steps (0-4), truncated on step 5


def test_vehicle_exit_sets_truncated_true(env_with_mocks, mock_sumo):
    """If lead vehicle leaves simulation -> truncated=True."""
    env_with_mocks.reset()

    # First call: all vehicles active
    # Second call: V002 no longer active
    mock_sumo.is_vehicle_active = Mock(side_effect=[
        True, True, True,  # reset checks
        True, False, True,  # step checks (V002 exited)
    ])

    _, _, _, truncated, _ = env_with_mocks.step(0)

    assert truncated is True


def test_truncated_does_not_apply_collision_reward(env_with_mocks, mock_sumo):
    """Truncation is not collision; no -100 penalty."""
    env_with_mocks.max_steps = 1  # Truncate after 1 step
    env_with_mocks.reset()

    # Safe distance (30m)
    mock_sumo.get_vehicle_state = Mock(side_effect=lambda vid: VehicleState(
        vid,
        x=0.0 if vid == "V001" else 30.0 if vid == "V002" else 60.0,
        y=0.0, speed=20.0, acceleration=0.0, heading=0.0, lane_position=0.0
    ))

    _, reward, terminated, truncated, info = env_with_mocks.step(0)

    assert truncated is True
    assert terminated is False
    assert info['reward_safety'] != -100.0  # Not collision reward
```

---

### Test File: `ml/tests/unit/test_hazard_injector.py`

```python
import pytest
from unittest.mock import Mock

from envs.hazard_injector import HazardInjector


# === Fixtures ===

@pytest.fixture
def mock_sumo():
    """Mock SUMOConnection."""
    mock = Mock()
    mock.is_vehicle_active = Mock(return_value=True)
    mock.set_vehicle_speed = Mock()
    return mock


@pytest.fixture
def injector():
    """HazardInjector with fixed seed."""
    return HazardInjector(seed=42)


# === Probability Tests (1 test) ===

def test_hazard_injector_respects_probability():
    """~30% of episodes get a hazard (statistical test)."""
    # Run 1000 trials, count how many have hazards
    hazard_count = 0

    for i in range(1000):
        inj = HazardInjector(seed=i)
        inj.reset()
        if inj._episode_will_have_hazard:
            hazard_count += 1

    # Should be ~300 ± some variance
    # Using 20-40% range (200-400) for robustness
    assert 200 <= hazard_count <= 400, f"Got {hazard_count}, expected ~300"


# === Window Tests (1 test) ===

def test_hazard_injector_only_injects_in_window(mock_sumo):
    """Hazards only injected between steps 30-80."""
    # Create injector that WILL have a hazard
    inj = HazardInjector(seed=42)

    # Force hazard to occur
    inj._episode_will_have_hazard = True
    inj._hazard_step = 50  # In window
    inj._hazard_injected = False

    # Steps outside window should not inject
    assert inj.maybe_inject(step=10, sumo=mock_sumo) is False
    assert inj.maybe_inject(step=29, sumo=mock_sumo) is False
    assert inj.maybe_inject(step=81, sumo=mock_sumo) is False

    # Step in window (at hazard_step) should inject
    assert inj.maybe_inject(step=50, sumo=mock_sumo) is True


# === Hazard Effect Test (1 test) ===

def test_hazard_injector_emergency_brake_stops_lead(mock_sumo):
    """EMERGENCY_BRAKE hazard sets lead (V002) speed to 0."""
    inj = HazardInjector(seed=42)
    inj._episode_will_have_hazard = True
    inj._hazard_step = 50
    inj._hazard_injected = False

    inj.maybe_inject(step=50, sumo=mock_sumo)

    mock_sumo.set_vehicle_speed.assert_called_once_with("V002", 0.0)


# === Return Value Test (1 test) ===

def test_hazard_injector_returns_true_when_injected(mock_sumo):
    """maybe_inject() returns True if hazard occurred."""
    inj = HazardInjector(seed=42)
    inj._episode_will_have_hazard = True
    inj._hazard_step = 50
    inj._hazard_injected = False

    # Before injection
    result_before = inj.maybe_inject(step=49, sumo=mock_sumo)
    assert result_before is False

    # At injection
    result_at = inj.maybe_inject(step=50, sumo=mock_sumo)
    assert result_at is True

    # After injection (can't inject twice)
    result_after = inj.maybe_inject(step=51, sumo=mock_sumo)
    assert result_after is False
```

---

## Implementation Steps

| Step | Task | Status |
|------|------|--------|
| 6.1 | Write 5 tests for `reset()` | [ ] |
| 6.2 | **VERIFY RED**: All 5 tests fail | [ ] |
| 6.3 | Implement `reset()` | [ ] |
| 6.4 | **VERIFY GREEN**: All 5 tests pass | [ ] |
| 6.5 | Write 3 tests for collision termination | [ ] |
| 6.6 | **VERIFY RED**: All 3 tests fail | [ ] |
| 6.7 | Implement collision detection in `step()` | [ ] |
| 6.8 | **VERIFY GREEN**: All 3 tests pass | [ ] |
| 6.9 | Write 3 tests for truncation | [ ] |
| 6.10 | **VERIFY RED**: All 3 tests fail | [ ] |
| 6.11 | Implement truncation logic in `step()` | [ ] |
| 6.12 | **VERIFY GREEN**: All 3 tests pass | [ ] |
| 6.13 | Write 4 tests for `HazardInjector` | [ ] |
| 6.14 | **VERIFY RED**: All 4 tests fail | [ ] |
| 6.15 | Implement `HazardInjector` | [ ] |
| 6.16 | **VERIFY GREEN**: All 4 tests pass | [ ] |
| 6.17 | **PHASE 6 COMPLETE**: 15/15 tests passing | [ ] |

---

## Critical Notes for BUILDER

### 1. Emulator Queue Clearing

The `emulator.clear()` call in `reset()` is **CRITICAL**. Without it, messages from the previous episode leak into the next episode, causing:
- Incorrect observations at episode start
- Training instability (agent sees "ghost" data)
- Non-reproducible behavior

**Verification test:** `test_reset_clears_emulator_message_queue`

### 2. SUMO Restart Pattern

TraCI doesn't have a clean "reload" API. The pattern is:
```python
if self._sumo_started:
    self.sumo.stop()  # Close TraCI connection
self.sumo.start()     # Restart simulation from beginning
```

Alternatively, `traci.load()` can be used but requires tracking the loaded configuration.

### 3. Distance Calculation

Use Euclidean distance in SUMO's coordinate space (x, y in meters):
```python
distance = sqrt((peer.x - ego.x)**2 + (peer.y - ego.y)**2)
```

For a straight-road convoy, this is approximately the longitudinal gap.

### 4. Terminated vs Truncated

| Condition | terminated | truncated | Reward |
|-----------|------------|-----------|--------|
| Collision (d < 5m) | True | False | -100 (safety) |
| Max steps reached | False | True | Normal |
| Vehicle exited | False | True | Normal |

**Key:** Collision is a "terminal state" (bad outcome). Truncation is "episode ran out of time" (neither good nor bad).

### 5. Hazard Injection Timing

Hazards inject at a **pre-determined step**, not probabilistically each step:
```python
# At episode reset:
if random() < 0.3:
    hazard_step = randint(30, 80)
else:
    hazard_step = None

# During episode:
if step == hazard_step:
    inject_hazard()
```

This ensures deterministic behavior given a seed.

### 6. Mock Strategy for Tests

Unit tests must NOT use real SUMO. Use mocks that return scripted VehicleState objects:
```python
mock_sumo.get_vehicle_state = Mock(side_effect=[
    VehicleState("V001", x=0, y=0, ...),   # First call
    VehicleState("V002", x=30, y=0, ...),  # Second call
    ...
])
```

---

## Files to Touch

| File | Changes |
|------|---------|
| `ml/envs/convoy_env.py` | Full rewrite (~150 lines) |
| `ml/envs/hazard_injector.py` | Full implementation (~80 lines) |
| `ml/tests/unit/test_convoy_env.py` | NEW - 11 tests |
| `ml/tests/unit/test_hazard_injector.py` | NEW - 4 tests |

---

## Exit Criteria

- [ ] All 15 Phase 6 tests pass
- [ ] All 58 previous tests still pass (no regressions)
- [ ] `reset()` clears emulator queue and restarts SUMO
- [ ] `reset()` returns (obs, info) with obs shape (11,)
- [ ] Collision (d < 5m) sets `terminated=True`
- [ ] Max steps sets `truncated=True`
- [ ] Vehicle exit sets `truncated=True`
- [ ] HazardInjector respects ~30% probability
- [ ] HazardInjector only injects in step window [30, 80]
- [ ] Hazard sets V002 speed to 0.0
- [ ] Coverage for ConvoyEnv >= 85%
- [ ] Coverage for HazardInjector >= 90%

---

## Quick Commands

```bash
# Run Phase 6 tests only
pytest roadsense-v2v/ml/tests/unit/test_convoy_env.py roadsense-v2v/ml/tests/unit/test_hazard_injector.py -v

# Run all unit tests (should be 73 after Phase 6)
pytest roadsense-v2v/ml/tests/unit/ -v

# Run with coverage
pytest roadsense-v2v/ml/tests/unit/ --cov=ml/envs --cov-report=term-missing
```

---

## Risks / Notes

### Risk 1: SUMO Restart Reliability

**Issue:** `traci.close()` + `traci.start()` may leave orphan processes if not handled correctly.

**Mitigation:** Use `try/finally` in `close()` and handle exceptions in `reset()`.

### Risk 2: Mock Complexity

**Issue:** Tests require complex mock orchestration for `get_vehicle_state` side effects.

**Mitigation:** Create helper fixtures for common scenarios (safe following, collision, etc.).

### Risk 3: Observation Consistency

**Issue:** First observation after `reset()` may have no peer data (emulator queue empty).

**Mitigation:** ObservationBuilder already handles missing vehicles with default values.

---

**Ready for BUILDER to proceed with Phase 6.**
